[TOC]

# 学前认识

## （一）STM32F103C8T6资源介绍

### 1、STM32F103C8T6芯片

![1744037787207](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744037787207.png)

### 2、F1系列片上资源/外设

| **英文缩写** | **名称**           | **英文缩写** | **名称**           |
| ------------ | ------------------ | ------------ | ------------------ |
| NVIC         | 嵌套向量中断控制器 | CAN          | CAN通信            |
| SysTick      | 系统滴答定时器     | USB          | USB通信            |
| RCC          | 复位和时钟控制     | RTC          | 实时时钟           |
| GPIO         | 通用IO口           | CRC          | CRC校验            |
| AFIO         | 复用IO口           | PWR          | 电源控制           |
| EXTI         | 外部中断           | BKP          | 备份寄存器         |
| TIM          | 定时器             | IWDG         | 独立看门狗         |
| ADC          | 模数转换器         | WWDG         | 窗口看门狗         |
| DMA          | 直接内存访问       | DAC          | 数模转换器         |
| USART        | 同步/异步串口通信  | SDIO         | SD卡接口           |
| I2C          | I2C通信            | FSMC         | 可变静态存储控制器 |
| SPI          | SPI通信            | USB OTG      | USB主机接口        |

NVIC：内核中管理中断的，比如中断优先级
SysTick：主要用来给操作系统提供定时服务，当然本课程不使用操作系统，因此可以用来生成Delay函数。
RCC：对系统的时钟进行配置，还有就是使能各模块的时钟。不给时钟的情况下，操作外设是无效的，外设也不会工作，这样的目的是降低功耗。
GPIO：引脚控制。
AFIO：复用IO口，可以完成复用功能的重定义，还有中断端口的配置。
EXTI：是外部中断，配置好外部中断后，当引脚有电平变化时候，就可以出发中断，让CPU来处理任务。
TIM：定时器，整个STM32中最常用、功能最多的外设。分为高级定时器（复杂）、通用定时器（常用）、基本定时器三种类型。生产PWM波最常用。
ADC：模数转换器，STM32内置了12位的AD转换器，可以直接读IO口的模拟电压值，无需外部联结AD芯片，使用非常方便。
DMA：是直接内存访问，这个可以帮助CPU完成搬运大量数据这样的繁杂任务。
USART：同步或者异步串口，我们常用的UART是异步串口的意思。
I2C：非常常用的通信协议。STM32内置了控制器，可以用硬件来输出时序波形。使用起来更高效，当然，用通用IO口来模拟时序波形也是没有问题的。
SPI：非常常用的通信协议。STM32内置了控制器，可以用硬件来输出时序波形。使用起来更高效，当然，用通用IO口来模拟时序波形也是没有问题的。
CAN：通信协议，一般用于汽车领域。
USB：通信协议，生活中到处都是，可以通过STM32USB外设制作模拟鼠标，模拟U盘。
RTC：是实时时钟，在STM32内部完成年月日、时分秒的计时功能，而且可以接外部备用电池，即使掉点也能正常运行。
CRC：一种数据的校验方式，用于判断数据正确性，有了这个外设的支持，进行校验就会更方便一些。
PWR：电源控制，可以让芯片进入睡眠模式等状态。来达到省点的目的。
BKP：备份寄存器，一段存储器，当系统掉电，仍可用备用电池保持数据，这个根据需要可以完成一些特殊功能。
IWDG：独立看门狗
WWDG：窗口看门狗，当单片机因为电磁干扰四级或者程序设计不合理出现死循环时候，看门狗可以及时复位芯片，保证系统的稳定性。

**下面四个功能是C8T6没有的**

~~~~下面这四个C8T6没有，具体需要看手册。
DAC：数模转换器，可以直接在IO口输出模拟电压。
SDIO：是SD卡接口，可以用来读取SD卡。
FSMC：是可变静态存储控制器，可以用于扩展内存，或者配置成其他总线协议，用于某些硬件的操作。
USB OTG：用OTG功能，可以让STM32作为USB主机去读取其他USB设备。
~~~~

### 3、芯片命名规则

![1744037939581](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744037939581.png)

### 4、芯片系统结构

在小容量、中容量和 大容量产品中，主系统由以下部分构成： 

● 四个驱动单元： 

─ Cortex™-M3内核DCode总线(D-bus)，和系统总线(S-bus)  

─ 通用DMA1和通用DMA2  

● 四个被动单元 

─ 内部SRAM  

─ 内部闪存存储器 

─ FSMC  

─ AHB到APB的桥(AHB2APBx)，它连接所有的APB设备 

25/754 

这些都是通过一个多级的AHB总线构架相互连接的，如下图所示：

![1744037975807](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744037975807.png)

### 5、引脚定义

![](E:\C8t6\江科大\参考文档\STM32F103C8T6引脚定义.png)

**注意**：【资料文档中】红色是电源相关引脚，标蓝色是最小系统相关引脚，标绿色的是IO口、功能口引脚
没有加粗的IO口需要另外配置，不能直接使用。

STM32采用分区供电的方式，因此这些引脚都接对应电压就可以了。	如果要想要STM32正常工作，首先就需要吧电源部分和最小系统部分的电路连接好。也就是图中红色和蓝色的部分。

另查阅网络找到了具体硬件连接时的引脚图：

![](E:\C8t6\江科大\参考文档\引脚.webp)

### 6、启动配置

![1744038459689](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744038459689.png)

### 7、最小系统电路

单片机只有一个芯片是无法工作的，我们需要为它连接最基本的电路，即最小系统电路。
**【STM32供电电路】**3.3V和GND之间一般连接了一个滤波电容，会让电源更加稳定，一般遇到供电都会习惯性的加几个滤波电容。其中VBAT是接备用电池的，是给RTC和备份寄存器使用的。
**【晶振电路】**8MHz的主时钟晶振，STM32的主晶振一般都是8MHz的，通过内部锁相环倍频得到了72MHz的主频。连接到5、6引脚，另外还需要两个20pF的电容，作为起振电容，电容的另一端接地即可。
如果需要RTC的话，还需要再接一个32.768KHz的晶振（OSC32），电路和这个一样，但是接在3、4号引脚。因为32768是2的15次方，内部的RTC电路经过2^15分频就可以生成1秒的时间信号了。
**【复位电路】**10k的电阻和0.1μF的电容组成的，提供复位信号。产生先低电平然后电容充完电又变高电平，这个低电平信号就成为了复位信号，所以一上电的瞬间就复位了。当然他提供了一个摁键，当摁键摁下的时候电容接地放电了，然后松开就会发生复位的过程，产生复位信号。
**【启动配置】**拨动开关，在最小系统板上使用的是跳线帽来选择的。
**【下载端口】**如果是用ST-Link下载程序的话，就需要把SWDIO和SWCLK两个引脚印出来方便接线，GND是一定要引出来的，3.3V如果板子自己有供电的话就不用引，建议都引。



## （二）环境配置工程搭建

### 1、安装软件

Keil5 MDK、器件支持包、固件库、HAL库、STINK驱动、USB转串口驱动等

### 2、工程环境搭建与配置

**【开发方式说明】**STM32的工程结构比较复杂。其开发方式目前主要有三：基于寄存器的方式、基于标准库（库函数）的方式、基于HAL库的方式。
①一般用寄存器的方式最直接最高效，但是比较STM32的结构复杂，寄存器太多，所以不推荐。
②库函数的方式是官方写好函数来间接的配置寄存器，这种方式因为STM32封装比较难好，对开发人员比较友好。
③最后一种HAL库，比较适合快速上手的情况，但是这种方式隐藏了底层逻辑。
**【资料说明】**《STM32F10x_StdPeriph_Lib_V3.5.0》文件夹当中Libraries就有固件库建立工程的时候会用到，project文件夹是官方提供的例程和工程模板。第四个Utilities是STM32官方评估板的相关例程，小电路板的测评程序。 剩下的Release_Notes.html是发布文档，有版本说明；stm32f10x_stdperiph_lib_um.chm是说明文档，说明库函数如何使用。

![1744092289339](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744092289339.png)

#### （1）keil工程搭建

•建立工程文件夹，Keil中新建工程，选择型号

•工程文件夹里建立Start、Library、User等文件夹，复制固件库里面的文件到工程文件夹

•工程里对应建立Start、Library、User等同名称的分组，然后将文件夹内的文件添加到工程分组里

•工程选项，C/C++，Include Paths内声明所有包含头文件的文件夹

•工程选项，C/C++，Define内定义USE_STDPERIPH_DRIVER

•工程选项，Debug，下拉列表选择对应调试器，Settings，Flash Download里勾选Reset and Run

工程架构如下：

![1744092784923](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744092784923.png)

### 3、启动文件说明

C8T6选择md文件即可

| **缩写** | **释义**           | **Flash****容量** | **型号**          |
| -------- | ------------------ | ----------------- | ----------------- |
| LD_VL    | 小容量产品超值系列 | 16~32K            | STM32F100         |
| MD_VL    | 中容量产品超值系列 | 64~128K           | STM32F100         |
| HD_VL    | 大容量产品超值系列 | 256~512K          | STM32F100         |
| LD       | 小容量产品         | 16~32K            | STM32F101/102/103 |
| MD       | 中容量产品         | 64~128K           | STM32F101/102/103 |
| HD       | 大容量产品         | 256~512K          | STM32F101/102/103 |
| XL       | 加大容量产品       | 大于512K          | STM32F101/102/103 |
| CL       | 互联型产品         | -                 | STM32F105/107     |

## （三）代码编写

**`keil编写使用C语言`**

### 1、数据类型

| **关键字**         | **位数** | **表示范围**             | **stdint****关键字** | **ST****关键字** |
| ------------------ | -------- | ------------------------ | -------------------- | ---------------- |
| char               | 8        | -128 ~ 127               | int8_t               | s8               |
| unsigned char      | 8        | 0 ~ 255                  | uint8_t              | u8               |
| short              | 16       | -32768 ~ 32767           | int16_t              | s16              |
| unsigned short     | 16       | 0 ~ 65535                | uint16_t             | u16              |
| int                | 32       | -2147483648 ~ 2147483647 | int32_t              | s32              |
| unsigned int       | 32       | 0 ~ 4294967295           | uint32_t             | u32              |
| long               | 32       | -2147483648 ~ 2147483647 |                      |                  |
| unsigned long      | 32       | 0 ~ 4294967295           |                      |                  |
| long long          | 64       | -(2^64)/2 ~ (2^64)/2-1   | int64_t              |                  |
| unsigned long long | 64       | 0 ~ (2^64)-1             | uint64_t             |                  |
| float              | 32       | -3.4e38 ~ 3.4e38         |                      |                  |
| double             | 64       | -1.7e308 ~ 1.7e308       |                      |                  |

### 2、宏定义

关键字：

```c
#define
```

用途：用一个字符串代替一个数字，便于理解，防止出错;提取程序中经常出现的参数，便于快速修改
定义宏定义：

```c
#define ABC12345
```

引用宏定义：

```c
int a = ABC;	//等效于int a = 12345;
```

可以多层定义引用，方便修改：

```c
#define ABA	ABC 
#define ABC	2550
```

### 3、typedef定义

关键字：typedef
用途：将一个比较长的变量类型名换个名字,
便于使用定义typedef：

```c
typedef unsigned char uint8_t;
```

引用typedef：

```c
uint8_t a;	//等效于unsigned char a;
```

二者比较：①宏定义的新名字在左边，typedef的新名字在右边。
②宏定义不需要加分号，typedef必须加分号。③宏定义任何名字都可以换（改名范围更宽），typedef只能专门给变量类型换名字（防止变量重命名，更安全）。

### 4、结构体

注意：库函数中出现的频率比较高，理解结构体那是非常必要的。结构体也是一种数据类型
关键字：struct
用途∶数据打包，不同类型变量的集合
定义结构体变量∶

```c
struct{char x; int y; float z;}structName;
```

因为结构体变量类型较长，所以通常用typedef更改变量类型名引用结构体成员︰

```c
//通过结构体名称structName来获取/修改数据内容。
structName.x = 'A'；
structName.y = 66；
structName.z = 1.23；
//或指针方式
pstructName->x = 'A'；	//pstructName为结构体的地址pstructName->y = 66；
pStructName->z= 1.23;
```

### 5、枚举

关键字：enum
用途：定义一个取值受限制的整形变量,用于限制变量取值范围；宏定义的集合
定义枚举变量：

```c
enum{FALSE = 0，TRUE = 1} EnumName;
```

因为枚举变量类型较长，所以通常用typedef更改变量类型名引用枚举成员：

```c
EnumName = FALSE;	EnumName = TRUE;
```



# 一、GPIO输入输出

## (一)通用GPIO输出

### 1、GPIO介绍

●GPIO (General Purpose lnput Output)：通用输入输出口可配置为8种输入输出模式
●引脚电平∶OV~3.3V，部分引脚可容忍5V
●输出模式下可控制端口输出高低电平，用以驱动LED、控制蜂鸣器、模拟通信协议输出时序等
●输入模式下可读取端口的高低电平或电压，用于读取按键输入、外接模块电平信号输入、ADC电压采集、模拟通信协议接收数据等。

### 2、基本结构

全部都是挂载到外设APB2总线上的。

![1744094102015](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744094102015.png)

![1744094131373](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744094131373.png)

**分为两个部分，【输入部分】：**
一个引脚如果处于浮空状态，那么它的电平是不确定的，极易收到干扰。因此呢这里就加了上拉和下拉电阻。这里的电阻阻值还是比较大的，所以是一种弱上拉和弱下拉，不影响操作。这个小特技触发器其实就是斯密特触发器。**模电里这叫迟滞/滞回比较器，也就是施密特触发器的电路（电压变化是有抖动的，斯密特就是做了一个范围限定，只在某个阈值高低才出发导通。）**
**【输出部分】：**
数字部分可以由输出数据寄存器或者片上外设控制，两种控制方式通过这个数据选择器接到数据输出控制部分。如果选择通过输出数据寄存器进行控制，那就是普通的IO口输出。写对应寄存器的某一位即可控制。另一个位设置清除寄存器，这个可以用来单独操作寄存器的某一位，而不影响其他位，但这个寄存器只能整体读写。接下来连接到一个控制输出的MOS管，控制为开漏，推挽。
**因此想操作某一个端口而不影响其他端口，就需要一些特殊方式：**
①先读出这个寄存器的值，然后按位与和按位或的方式更改某一位，最后再将更改后的数据歇会去，在C语言中就是&=和|=的操作。这种方法比较麻烦，效率率不高，对于IO口而言不太合适。
②第二方式就是设置图中的位设置/清除选择寄存器——库函数操作。
③读写STM32“位带”区域，和51的位寻址作用差不多。早STM32中，专门分配有一段地址区域，这段地址映射了RAM和外设寄存器所有的位，读取这段地址的数据，就相当于读取所映射位置的某一位。这个方式我们本课程不会用到。

### 3、IO可配置8种模式

●前三个电路一样，区别在于上拉电阻和下拉电阻的接入，定义上下拉情况。
●模拟输入：ADC转换的专属配置模式，其他时候一般用不到。
●开漏输出/推挽输出：都是数字输出，可以控制高低电平，区别就是开漏输出的高电平是高组态，没有驱动能力。而推挽输出的高低电平都是具有驱动能力的。
**注意：**当配置成输出模式的时候，内部也可以顺便输入一下，没影响。
●复用推挽输出/复用开漏输出：引脚电平是由片上外设控制的。

| **模式名称** | **性质** | **特征**                                           |
| ------------ | -------- | -------------------------------------------------- |
| 浮空输入     | 数字输入 | 可读取引脚电平，若引脚悬空，则电平不确定           |
| 上拉输入     | 数字输入 | 可读取引脚电平，内部连接上拉电阻，悬空时默认高电平 |
| 下拉输入     | 数字输入 | 可读取引脚电平，内部连接下拉电阻，悬空时默认低电平 |
| 模拟输入     | 模拟输入 | GPIO无效，引脚直接接入内部ADC                      |
| 开漏输出     | 数字输出 | 可输出引脚电平，高电平为高阻态，低电平接VSS        |
| 推挽输出     | 数字输出 | 可输出引脚电平，高电平接VDD，低电平接VSS           |
| 复用开漏输出 | 数字输出 | 由片上外设控制，高电平为高阻态，低电平接VSS        |
| 复用推挽输出 | 数字输出 | 由片上外设控制，高电平接VDD，低电平接VSS           |

【寄存器配置】
正常高低寄存器、位清除/设置寄存器、端口配置锁定寄存器。
【GPIO的输出速度】
00:输入模式(复位后的状态)

01:输出模式,最大速度10MHZ

10:输出模式,最大速度2MHZ

11:输出模式,最大速度50MHZ

为控制引脚的翻转速度，设计出来是为了低功耗和稳定性。

### 4、LED介绍

●LED：发光二极管，正向通电点亮，反向通电不亮
●有源蜂鸣器：内部自带振荡源，将正负极接上直流电压即可持续发声，频率固定
●无源蜂鸣器：内部不带振荡源，需要控制器提供振荡脉冲才可发声，调整提供振荡脉冲的频率，可发出不同频率的声音
![1744094446642](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744094446642.png)

### 5、硬件电路接线方式

#### （1）LED电路

限流电阻一般是要加上的，以防止电流过大。一下是两种控制LED的方式。该如何选择呢？一般是看IO口的驱动能力了，在单片机电路当中一般是选择第一种，因为很多单片机都采用了高电平弱驱动，低电平强驱动的方式，这样一定程度上可以避免高低电平打架。

**低电平控制亮**

![1744094499060](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744094499060.png)

**高电平控制亮**

![1744094531557](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744094531557.png)

#### （2）蜂鸣器电路

使用了三极管开关驱动电路方案，三极管开关是最简单的驱动电路了。对于功率稍微大一点的，直接用IO口驱动可能会对单片机负担过重，这时候就可以用一个三极管驱动电路来完成驱动任务。
![1744094549962](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744094549962.png)

![1744094571909](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744094571909.png)

### 6、面包板的使用方法

其内部金属条，按着连接即可导通电流。

![1744094599972](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744094599972.png)



## （二）通用GPIO输入

### 1、摁键介绍

按键：常见的输入设备，按下导通，松手断开

按键抖动：由于按键内部使用的是机械式弹簧片来进行通断的，所以在按下和松手的瞬间会伴随有一连串的抖动。因此一般程序需要消抖，最简单是就是加一个延时耗过去，在判断高低电平就可以了。

![1744094889264](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744094889264.png)

### 3、传感器模块介绍

**本文件只介绍项目过程中调试过的模块。**

•传感器模块：传感器元件（光敏电阻/热敏电阻/红外接收管等）的电阻会随外界模拟量的变化而变化，通过与定值电阻分压即可得到模拟电压输出，再通过电压比较器进行二值化即可得到数字电压输出

![1744095024602](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744095024602.png)

![1744095032546](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744095032546.png)

接地的电容是其滤波作用的，分析时候可以直接拿掉。

电路中经常出现的弱上拉，强上拉，弱下拉，强下拉。这里的去那个若就是指电阻阻值的大小。因此该传感器的最终输出电压就是在弹簧拉车下最终杆子的高低。
N1可以看做替换部分：光敏电阻、热敏电阻、红外接收管（另外对应一个红外发射管）



# OLED显示屏

## （一）OLED简介

•OLED（Organic Light Emitting Diode）：有机发光二极管

•OLED显示屏：性能优异的新型显示屏，具有功耗低、相应速度快、宽视角、轻薄柔韧等特点

•0.96寸OLED模块：小巧玲珑、占用接口少、简单易用，是电子设计中非常常见的显示屏模块

•供电：3~5.5V，通信协议：I2C/SPI，分辨率：128*64

![1744095127958](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744095127958.png)

## （二）硬件电路

这里参考实验11-2 硬件SPI读写W25Q64

套件中是4针OLED

【原理图】

![1744095354055](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744095354055.png)

【接线图】

![1744095274646](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744095274646.png)

# 中断

## （一）中断系统

### 1、中断的概念

#### （1）中断

**中断**：在主程序运行过程中，出现了特定的中断触发条件（中断源），使得CPU暂停当前正在运行的程序，转而去处理中断程序，处理完成后又返回原来被暂停的位置继续运行。

如果没用中断，那CPU总是询问有  没有事件的发生，就没法干其他活了，也只能靠delay来延时。有了中断之后，CPU可以专心执行当前程序，有中断时候就才去执行中断，不用询问，提高了效率。

#### （2）中断优先级

**中断优先级**：当有多个中断源同时申请中断时，CPU会根据中断源的轻重缓急进行裁决，优先响应更加紧急的中断源。

#### （3）中断嵌套

**中断嵌套**：当一个中断程序正在运行时，又有新的更高优先级的中断源申请中断，CPU再次暂停当前中断程序，转而去处理新的中断程序，处理完成后依次进行返回。

### 2、中断执行流程



![1744099641834](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744099641834.png)

中断不需要调用，当中断来临时，由硬件自动调用这个函数。断点的信息编译器自动帮我们保存好了，以便处理完中断后继续执行。

### 3、STM32中断

•68个可屏蔽中断通道，包含EXTI、TIM、ADC、USART、SPI、I2C、RTC等多个外设

•使用NVIC统一管理中断，每个中断通道都拥有16个可编程的优先等级，可对优先级进行分组，进一步设置抢占优先级和响应优先级

![1744099892274](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744099892274.png)

我们程序当中的中断函数，的地址是不确定的，是编译器自动分配的。但是我们的中断跳转，由于是硬件的限制，只能跳到固定的执行程序。所以为了能让硬件能跳转到不固定的硬件函数里，这里就需要在内存中定义一个地址的列表即——**中断向量表**。当中断发生后，就跳到这个固定位置。然后由编译器，在加上一条跳转到中断函数的代码。

### 4、NVIC中断优先级的结构

因为STM32的中断很多，如果外部中断直接连接到CPU，CPU就会多出很多引脚。所以二者之间就有一个NVIC出现了。用于排列中断执行的优先级，STM32**任何时候都是优先级高的先响应**。

![1744099984507](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744099984507.png)

### 5、NVIC优先级分组

NVIC的**中断优先级**由优先级寄存器的4位（0~15)决定，这4位可以进行切分，分为高n位的抢占优先级和低4-n位的响应优先级。

**抢占优先级高**的可以中断嵌套，响应优先级高的可以优先排队，抢占优先级和响应优先级均相同的按中断号排队

| **分组方式** | **抢占优先级**  | **响应优先级**  |
| ------------ | --------------- | --------------- |
| 分组0        | 0位，取值为0    | 4位，取值为0~15 |
| 分组1        | 1位，取值为0~1  | 3位，取值为0~7  |
| 分组2        | 2位，取值为0~3  | 2位，取值为0~3  |
| 分组3        | 3位，取值为0~7  | 1位，取值为0~1  |
| 分组4        | 4位，取值为0~15 | 0位，取值为0    |



## （二）EXTI外部中断

中断系统是管理和执行中断的逻辑结构，外部中断是众多能产生中断的外设之一。我们通过外部中断来学习中断。

### 1、EXTI简介

**EXTI (Extern lnterrupt)外部中断**
EXTI可以监测指定GPIO口的电平信号，当其指定的GPIO口产生电平变化时，EXTI将立即向NVIC发出中断申请，经过NVIC裁决后即可中断CPU主程序,使CPU执行EXTI对应的中断程序
**支持的触发方式：**上升沿/下降沿/双边沿/软件触发
**支持的GPIO口：**所有GPIO口，但相同的Pin不能同时触发中断
**通道数：**16个GPIO_Pin（主要），外加PVD输出、RTC闹钟、USB唤醒、以太网唤醒
**触发响应方式：**
①中断响应（向CPU申请中断，让其执行中断函数，会触发中断引脚电平）
②事件响应（STM32对外部中断增加的一种额外的功能，当外部中断检测到引脚电平变化时，正常的流程是选择触发中断，但在STM32中也可以触发一个事件，这种触发的外部信号不会通向CPU了，也就是不会触发中断，而是触发其他外设的操作，触发ADC、触发DMA。）
**<u>【注意】：</u>**因为NVIC是内核外设，所以数据手册要去内核手册寻找。

### 2、EXTI基本结构

引脚比较多，每一个GPIO都有16pin的话，那外部中断的GPIO就的主要通道就不够了，所以这里会有一个，**AFIO数据选择器**，它可以在这前面3个GPIO外设的16个引脚里选择其中一个连接到后面或的通道里，前面提到，相同的pin不能同时触发中断。**这是因为经过AFIO进行选择后<u>只能有一个</u>接到EXTI的通道上**。

然后另外的四个（PVD/RTC/USB/ETH）蹭网的也接入进来，一共组成了EXTI的20个输入信号。

然后进一步的分成了两种输出信号，一种的NVIC输出中断信号，其中的9~5会触发同一个函数，15~10也会触发同一个中断函数，编程的时候需要根据标志位来确定到底是哪一个中断函数。一种是其他外设的输出信号，有20条线。

![1744100363063](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744100363063.png)

### 3、内部电路

**【AFIO复用IO口】**

•AFIO主要用于引脚复用功能的选择和重定义

•在STM32中，AFIO主要完成两个任务：**复用功能引脚重映射**、中断引脚选择

![1744100435238](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744100435238.png)



## （三）TIM定时器中断

### 1、TIM简介

●TIM (Timer) 定时器，定时器可以对输入的时钟进行计数（定时器本质是个计数器），并在计数值达到设定值时触发中断。是STM32中功能最强大、结构最复杂的外设。
●16位计数器、预分频器、自动重装寄存器的时基单元，在72MHz计数时钟下可以实现最大59.65s的定时。不仅具备基本的定时中断功能，而且还包含内外时钟源选择、输出比较、输入捕获、主从触发模式、编码器接口等多种功能（其它功能可以自行扩展学习）
STM32支持**级联模式**（一个定时器的输出当做另一个定时器的输入），一个定时器59.65s定时，级联一个（59.65 x 65536^2）定时8千年，级联两个（59.65 x 65536^4）定时34万亿年。
●根据复杂度和应用场景分为了**高级定时器、通用定时器、基本定时器**三种类型。库函数中出现TIM9/10/11的定时器一般用不到。还有总线的连接，RCC开启时钟的时候要注意编号数字。功能如下所示：
![1744100748741](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744100748741.png)

STM32F103C8T6定时器资源：TIM1（一个高级）、TIM2、TIM3、TIM4（三个通用）

### 2、定时器结构图

#### （1）基本定时器

![img](https://cdn.nlark.com/yuque/0/2024/png/25954489/1711937205725-7e2afc7a-625c-4a22-90d5-99aa7582781f.png)

**基本流程：**基准时钟——预分配器——计数器——产生中断/事件——中断优先级——CPU
【时基单元】：与分频器之前就是基准计数时钟的输入，连接到了内部时钟，其频率一般是系统主频72MHz，然后与分频器可以对其进行分频（**是十六位的，可以分0~65535频**，分频的目的是降低频率便于改变计算，使得外设间互不干扰，控制其工作速度，匹配外设要求，有的外设是检测不到72M这么快的速度的）。计数器对分频后的时钟单位进行计数，重装载寄存器保存设定的数值，计数过程二者不断比较，达到设定目标值（0~65535）时候，就会产生中断并清零计数器。

向上的小箭头表示可以产生中断，计数值的中断称为更新中断，中断后通往NVIC，所以接下来配置其定时器通道，就可以得到CPU响应。向下的箭头表示更新事件，更新事件不会触发中断，但是可以触发内部其他电路的工作。

【主模式触发DAC功能】STM32的特色主从触发模式，可以让内部硬件在不受程序控制下实现自动运行，极大的减轻CPU的负担。因为上图中如果在定时器产生的中断中去控制DAC的输出，此时主程序会被频繁中断，占用CPU资源，影响到程序的运行和其他中断的响应。所以使用主模式，产生的中断事件映射到出发输出TRGO的位置，使其控制输出DAC，这样便不需要在中断里触发DAC转换了。

#### （2）通用定时器

![1744100953321](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744100953321.png)

【定时器计数方式】**向上自增（从0开始增加，常用）**，向下自减（从设定值开始），中央对齐模式（先从零开始再从设定值开始），基本定时器只有向上自增一种方式，其余类型的定时器三种模式均有。
***【时钟源输入】***基本定时器只能是内部的时钟源，但是通用定时器可以多选择外部时钟源信号。
外部时钟输入模式2的输入：可以走ETR通道。经过滤波整形电路，输出基准时钟；
<u>外部时钟输入模式1的输入：可以选择ITR信号，这部分信号是来自于其他定时器。TRGO接到其他定时器的同时又接到了ITRx上，具体连接关系可以通过表格来了解。可用于级联；</u>

![1744101223581](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744101223581.png)

另外还可以选择CH1引脚边沿，CH1引脚和CH2引脚，可用于**输入捕获，检测频率**。
<u>总结：</u>输入还是比较复杂的，但是一般常用RCC内部时钟，而要使用外部时钟首选ETR输入就行了，其他的输入范围是为了一些特殊应用场景设计的，后续可了解。
【编码器接口】可以读取正交编码器的输出波形，后续讲解。
【输入捕获电路】四个通道，CH1~CH4
【输出比较电路】总共四个通道输出，与输入捕获电路公用一个组寄存器，因此不能同时使用。

#### （3）高级定时器

![1744101371057](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744101371057.png)

【重复计数器】：控制计数器中断的产生，可以隔几个周期触发更新中断，相当于对输出的更新中断信号进行了一次分频。
**【DTG死区生成电路】**：在框图中其前三路可以输出两个互补的PWM波输出，用于**控制三相无刷驱动**。因为其只需要三路，因此第四路没什么变化。在开关切换的瞬间，由于器件的不理想，造成短暂的直通现象，因此在输出之前加上了死区生成电路，**在开关切断的瞬间，产生一定时间的死区，让桥臂的上下管全都关断，防止直通现象。**
【刹车输入】：给电机驱动提供安全保障，如果外部引脚产生了刹车信号，或者内部时钟信号消失，控制电路就会自动切断电机的输出，防止意外。



## （四）时基单元相关时序分析

定时器中断，即定时产生一个中断。需要实现时钟、秒表等计时的时候都需要这个功能。

`定时器中断基本结构图`

![1744101533306](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744101533306.png)

**预分频器时序**

![1744101588348](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744101588348.png)

当与分频器CNT_EN使能时候，计数器时钟才运行，但定时器仍然过了一段时间才发生改变，其改变的位置处于计数器寄存器清零部分，可知其重装值为FC，同时也会产生一个更新事件。后三行时序是一个缓冲机制，在计数周期过程中改变预分频系数，并不会直接改变定时器计数，而是等待计数周期结束后，产生了更新事件，此时预分频寄存器的值才生效，保障了稳定。

**计数器计数频率：**`CK_CNT=CK_PSC/(PSC+1)`



**计数器时序**

![1744101620752](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744101620752.png)

**定时器溢出频率：**`CK_CNT_OV=CK_CNT/(ARR+1)=CK_PSC/(PSC+1)/(ARR+1)`

同样的，也存在缓冲机制。**注：框图中的寄存器带有阴影的都是这样的缓冲机制，用或者不用均可自行设置。**



**计数器无预装时序**

没有缓冲的情况下

![1744101938400](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744101938400.png)

正常的计数周期后，变化分频频率。



**计数器有预装时序**

![1744101998200](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744101998200.png)

修改分频没有缓冲直接改变频率，会导致计数器一直增加至FFFF全满，然后才清零。



## （五）RCC时钟树

时钟树是STM32用来产生和配置时钟，并且把配置好的时钟发送到各个外设的系统，是所有外设运行的基础，所以是最先要配置的东西。

![1744102093856](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744102093856.png)

当HSI被用于作为PLL时钟的输入时，系统时钟能得到的最大频率是64MHz。

上图分为两个部分，一是时钟产生电路，二是时钟配置电路。

### 1、时钟产生电路

【资源】：一般使用外部晶振， 比较稳定，除非精度不高可以使用内部。
○内部8MHz；
○外部4~16MHz高速石英晶体振荡器，也就是晶振，一般都是接8MHz；
○外部的32.768KHz低速晶振，这个一般是给RTC提供时钟的。
○内部40KHz低速RC震荡期，这个可以给看门狗提供时钟。
【启动过程】：首先以内部时钟8M启动，再启动外部时钟，进入PLL锁相环进行倍频，8MHz倍频9倍，获得72MHz。（据网友所说PLL不止9倍，可以用倍频16倍，进行超频运行）
如果外部晶振坏了，时钟会慢10倍。
【CSS】：时钟安全系统，负责切换时钟。比如先前提到的刹车系统里也有。

### 2、时钟分配电路

默认情况下，无论是什么定时器，其内部基准时钟都是72MHz。如果更改了系统初始化函数SystemInit()的配置，需要重新计算速度。



# PWM

## （一）TIM输出比较

### 1、简介

**【输出比较功能】**

- OC (Output Compare)输出比较，重要，主要用来输出PWM波形的，常用驱动电机。
- 输出比较可以通过比较CNT与CCR寄存器值的关系，来对输出电平进行置1、置0或翻转的操作，用于输出一定频率和占空比的PWM波形
- 每个高级定时器和**通用定时器**都拥有4个输出比较通道**（主要讨论通用定时器的输出比较功能）**
- 高级定时器的前3个通道额外拥有死区生成和互补输出的功能

**【PWM简介】**

- PWM (Pulse Width Modulation)脉冲宽度调制
- <u>在具有**惯性的系统**中，可以通过对一系列脉冲的宽度进行调制，来等效地获得所需要的模拟参量，常应用于电机控速等领域</u>
- **PWM参数：**`频率=1/ Ts`、`占空比= Ton/ Ts`、`分辨率=占空比变化步距`

![1744102628756](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744102628756.png)

### 2、输出比较通道（通用）

![1744102681716](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744102681716.png)

通用定时器通道1和高级定时器的第四个通道基本是一样的。

**主要流程说明：**ETRF输入是定时器的一个小功能，一般不用，不需要了解/**CNT和CCR1**比较产生信号——传入**<u>输出模式控制器</u>**——改变OC1REF的高低电平——映射到主模式的控制器/主要是通往TIMx_CCER(极性选择，高低电平是否翻转)——输出使能，选择通道——通道输出

**【输出模式控制器】：**八中模式

| **模式**         | **描述**                                                     |
| ---------------- | ------------------------------------------------------------ |
| 冻结             | CNT=CCR时，REF保持为原状态                                   |
| 匹配时置有效电平 | CNT=CCR时，REF置有效电平                                     |
| 匹配时置无效电平 | CNT=CCR时，REF置无效电平                                     |
| 匹配时电平翻转   | CNT=CCR时，REF电平翻转                                       |
| 强制为无效电平   | CNT与CCR无效，REF强制为无效电平                              |
| 强制为有效电平   | CNT与CCR无效，REF强制为有效电平                              |
| PWM模式1         | 向上计数：CNT<CCR时，REF置有效电平，CNT≥CCR时，REF置无效电平   向下计数：CNT>CCR时，REF置无效电平，CNT≤CCR时，REF置有效电平 |
| PWM模式2         | 向上计数：CNT<CCR时，REF置无效电平，CNT≥CCR时，REF置有效电平   向下计数：CNT>CCR时，REF置有效电平，CNT≤CCR时，REF置无效电平 |

冻结模式：设置后输出停止，高低电平不变。

有效电平和无效电平通常用于高级定时器的说法关断、刹车功能配合表述的，可当成高低电平控制看待。

电平翻转：比如设置CCR=0时候，每次CNT更新清0就会产生一次CNT=CCR的事件，这就会导致输出电平翻转一次，每更新两次，输出为一个周期，占空比始终为50%；改变定时器频率时候，输出波形频率也会随之改变。`输出波形的频率=更新频率/2`

强制有效/无效电平：想暂停输出，并保存高电平或者低电平。

PWM模式1：频率和占空比都可调

PWM模式2：频率和占空比都可调，二者互为REF电平取反情况。比较灵活。

### 3、输出比较通道（高级）

![1744102825749](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744102825749.png)

OC1和OC1N是互补输出。死区发生器是防止两个输出同时打开，发热损耗。

### 4、<u>PWM产生</u>

![1744102979867](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744102979867.png)

【运行控制+时基单元】左边的时钟源选择，进入到时基单元后进行相关配置，配置好后CNT计数器就可以不断的自增运行了——往下进入输出比较单元

**【输出比较单元】**<u>一共有4路。最开始是进入CCR捕获/比较寄存器**（上图CCR比较的值为30的红色线，可以通过更改值来改变占空比）**——输出模式控制（图中假设选择了PWM1模式），输出REF电平——IO输出</u>

**【PWM参数计算】**

- PWM频率：`Freq= CK_ PSC/(PSC+ 1)/ (ARR+ 1)`，PWM的频率=更新周期
- PWM占空比：``Duty= CCR/ (ARR+ 1)`，CCR的变化范围取决于ARR的值
- PWM分辨率：`Reso= 1/(ARR+1)`



## （二）TIM输入捕获

### 1、简介

- IC (Input Capture)输入捕获
- 输入捕获模式下，当通道输入引脚出现**指定电平跳变**时（跳变方向可配置，总的类似外部中断），当前CNT的值将被锁存到CCR中，可用于**测量PWM波形的频率、占空比、脉冲间隔、电平持续时间等参数**
- 每个高级定时器和通用定时器都拥有4个输入捕获通道
- 可配置为**PWMI模式**，同时测量频率和占空比
- 可配合**主从触发模式**，实现硬件全自动测量

![1744103218394](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744103218394.png)

输出部分产生一个中间波形OCxRef（高有效）作为基准，链的末端决定最终输出信号的极性。

### 2、频率测量

![1744103324627](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744103324627.png)

•测频法：在闸门时间T内，对上升沿计次，得到N，则频率
$$
f_x=N / T
$$
闸门时间内，N越小误差越大，因此适合高频信号。

•测周法：两个上升沿内，以标准频率fc计次，得到N ，则频率
$$
f_x=f_c  / N
$$
N计次多可以减小误差，因此适合低频信号。

•中界频率：测频法与测周法误差相等的频率点
$$
f_m=√(f_c  / T)
$$
**待测信号频率<中界频率时，使用测周法；待测信号频率>中界频率时，选用测频法。**



**定时器实现测周法**  上升沿用于触发捕获，两上升沿间，时钟源fc产生的**CNT**值作为N，用于计数计时，使用共享求得fx，清零CNT。

### 3、主从出发模式

**主模式：**可以将定时器内部的信号，映射到TRGO引脚，**用于触发别的外设**

**从模式：**接受其他外设或者自身的信号，即**被别的信号控制**。其触发源选择就是选择从模式的出发信号源，信号源选择TRGI去触发从模式，从模式可以在列表中选择一项操作来**自动**执行。

![1744103490946](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744103490946.png)

### 4、输入捕获基本结构

TI1FP1带来触发信号，首先转运CNT的值到CCR里去，再触发Reset从模式给CNT清零。CCR1的值始终是最新一个周期的计数值N。因此，想要计算频率，只需要读取CCR1的值，在计算fc/N即可。纯硬件自动。

![1744103543596](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744103543596.png)

**注：**这里的CNT是有计数上限的，ARR一般设置为最大65535。如果信号频率太低，CNT计完就溢出了。另外从模式清零只有TI1FP1，TI2FP2，通道3、4只能开启捕获中断，在中断里手动清理，会消耗软件资源。

### 5、PWMI基本结构

这个PWMI模式，使用了两个通道同时捕获一个引脚。如图中波形，**上升沿、下降沿都捕获**，CCR1值上升沿开始的是整个周期，而在其中CCR2下降沿触发，只有半个周期（高电平）值。**此时二者一除便是占空比。**

![1744103618594](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744103618594.png)



## （三）编码器

略



# ADC

## （一）简介

- ADC (Analog-Digital Converter)模拟-数字转换器
- ADC可以将引脚上连续变化的模拟电压转换为内存中存储的数字变量，建立模拟电路到数字电路的桥梁
- **12位（分辨率）**逐次逼近型ADC，**1us**（1MHz）转换时间
- 输入电压范围**：0~3.3**V，对应**转换结果范围：0~4095（0~2^12-1）**
- 18个输入通道，可 测量16个外部和2个内部信号源
- **规则组**（常规事件）和**注入组**（突发事件）两个转换单元
- 模拟看门狗自动监测输入电压范围
- STM32F103C8T6 ADC资源：ADC1、ADC2， 10个外部输入通道

一般读取引脚我们只能获取高电平或者低电平，但是使用ADC之后，就可以把高低电平之间的任意电压进行量化，最终用一个变量表示，读取这个变量，就可以知道计算得知具体电压。

## （二）ADC原理结构

### 1、逐次逼近型ADC学习

下图中的通道选择开关表示一个可以通过模拟信号的数据选择器，有多少ADC的通道数即多少的开关，STM32内部的ADC有18个输入通道。

![1744103762223](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744103762223.png)

那么如何知道通道输入的电压是多少呢？通过比较器进行逐次的比较，即从高位到低位依次判断是1还是0的过程。（8位判断8次，12位判断12次，具体可以参考C51教程）一遍遍的比较至**近似相等**。

**VREF参考电压：**用于DAC输出电压比较值，也可以说是整个ADC的参考电压。一般情况下ADC的输入范围和供电是一致的。（不一样的，比如音频的ADC）

### 2、ADC框图

![1744103842315](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744103842315.png)

- **触发ADC转换的信号：**①软件触发，在程序中调用一条代码，就可以启动转换了。
- ②硬件触发，就是这里的这些触发源（EXTI_11/EXTI15开始连接的两控制器）。
- **参考电压：**芯片的VDDA和VSSA在电路中默认接了VREF，因此没有VREF±引脚。同电源0~3.3V
- **ADCCLK：**来源于外设总线预分频器，**最大14MHz**，因此把时钟源分频时候不能弄超了。
- **数据寄存器：**存数据

- - DMA数据搬运功能：下节讲解

- **模拟看门狗：**可以存一个阈值高限和一个阈值低限。启动并指定了看门的通道，一旦数据超过限制范围，就会乱叫，即申请一个中断AWD。
- **通道组完成信号：**转换完成之后，也会有一个信号，EOC是规则组的完成信号，JEOC注入组完成信号。这些信号可以渠道NVIC申请中断

### 3、ADC基本结构

使能ADC：选择输入通道——开关选择——进入转换器（分两组）——接收触发和时钟信号，开始转换，发送转换完成信号，输出数据保存到寄存器（不同组寄存器个数不同）

------

| **通道** | **ADC1**     | **ADC2** | **ADC3** |
| -------- | ------------ | -------- | -------- |
| 通道0    | PA0          | PA0      | PA0      |
| 通道1    | PA1          | PA1      | PA1      |
| 通道2    | PA2          | PA2      | PA2      |
| 通道3    | PA3          | PA3      | PA3      |
| 通道4    | PA4          | PA4      | PF6      |
| 通道5    | PA5          | PA5      | PF7      |
| 通道6    | PA6          | PA6      | PF8      |
| 通道7    | PA7          | PA7      | PF9      |
| 通道8    | PB0          | PB0      | PF10     |
| 通道9    | PB1          | PB1      |          |
| 通道10   | PC0          | PC0      | PC0      |
| 通道11   | PC1          | PC1      | PC1      |
| 通道12   | PC2          | PC2      | PC2      |
| 通道13   | PC3          | PC3      | PC3      |
| 通道14   | PC4          | PC4      |          |
| 通道15   | PC5          | PC5      |          |
| 通道16   | 温度传感器   |          |          |
| 通道17   | 内部参考电压 |          |          |

![1744103991471](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744103991471.png)

手册引脚中只有IN0~9共10个通道，其他地方就没有了。因此芯片只有10个外部输入通道。下图中ADC12_IN0的意思是ADC1和ADC2的IN0都是在PA0上的，即引脚全都是相同的。因此ADC1和ADC2可以同时运行，即双ADC模式。比如可以配合组成同步或者**交叉运行（对着一个通道交叉的采样，增大采样的频率）**。

本芯片没有ADC3。

### 4、规则组的四种转换模式

参数：单次/连续、扫描/非扫描
**【单次转换，非扫描模式】**

![1744104086445](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744104086445.png)

在非扫描模式下，只有序列1的位置有效，这时候同时选中一组的方式就简化为选中一个的方式。
但这一个位置可以选择不同的通道，然后触发转换一次。EOC标志位置1，整个转换过程结束。
如果想再次转换，只能再次触发。如果想换通道，那就触发转换之前将其通道更改。
（没有用到菜单列表）

**【连续转换，非扫描模式】**

![1744104231813](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744104231813.png)

仍然是非扫描模式，菜单列表**只用第一个**。区别是一次转换完成标志位置1结束后，还会继续触发转换（**不需要等待时间**），一旦开始，一直持续。

想要数据就一直从寄存器去就是了。

（但有可能功耗会上升）

**【单次转换，扫描模式】**

![1744104262625](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744104262625.png)

**扫描模式**，每触发一次，转换结束后就会停下来。不过会把菜单列表的通道都转换了。（**列表通道可以任意指定，可以重复指定**）

因此，还需要有一个**通道数目**参数。对指定数目进行一次转换，存放到数据寄存器中（**为了防止数据被覆盖，需要及时使用DMA将数据搬运走**）

**【连续转换，扫描模式】**

![1744104360704](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744104360704.png)

连续扫描模式，一旦开始，不会停止转换，全部通道扫描。



## （三）AD转换过程补充

### 1、触发控制

通过设置EXTSEL寄存器来选择控制源。

![1744104437885](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744104437885.png)

- TIM8_TRGO事件只存在于大容量产品 
- 对于规则通道，选中EXTI线路11或TIM8_TRGO作为外部触发事件，可以分别通过设置ADC1和ADC2的 ADC1_ETRGREG_REMAP位和ADC2_ETRGREG_REMAP位实现。

### 2、数据对齐

数据寄存器是16位的，ADC是12位的，因此存在一个数据对齐的问题，以便正确获取数据。**一般使用右对齐，直接得到转换结果。**

数据右对齐![1744104524859](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744104524859.png)

数据左对齐![1744104544902](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744104544902.png)

数据对齐常用于控制精度，如果后面的四位不要了，可以左对齐后只取高八位。

### 3、转换时间

**AD转换的步骤：**<u>采样，保持；量化，编码</u>

**==STM32 ADC的总转换时间为：==**
$$
T_C= 采样时间 + 12.5个ADC周期
$$


需要采样保持的原因是，电压是波动的，因此想要在转换过程中，保持稳定。就需要这个采样保持电路。整个过程耗费时间即为**采样时间**（越大越能防止毛刺信号，不过转换时间也会延长）。

12位的ADC需要12个转换周期，另外0.5个周期不知道干嘛。

**例如：**当ADCCLK= 14MHz，采样时间为1.5个ADC周期`TCONV= 1.5 + 12.5 = 14个ADC周期= 1μs`

这就是最快时间了，再快需要ADCCLK超频，稳定性不好。

### 4、校准

- ADC有一个内置**自校准模式**。校准可大幅减小因内部电容器组的变化而造成的准精度误差。校准期间，在每个电容器上都会计算出一个误差修正码(数字值)，这个码用于消除在随后的转换中每个电容器上产生的误差
- 建议在每次上电后执行一次校准
- 启动校准前，ADC必须处于关电状态超过至少两个ADC时钟周期

**校准过程是固定的，只需要注意调用即可**。

### 5、硬件电路

ADC外围电路设计：方便信号接入。

![1744190515627](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744190515627.png)

①电位器产生可调电压（滑动变阻器），注意**阻值不要太小**。

②传感器产生输出电压电路，其光敏电阻、热敏电阻、红外接收管、麦克风等都可以**等效为一个可变电阻**。因为电阻阻值没法直接测量，就需要串联一个电阻分压（**阻值近似传感器阻值**），来得到一个反应电阻值电压的电路。

③电压转换电路，同样的需要电阻进行分压。根据分压公式计算PA2电压范围。`PA2=VIN/50K*33K`。如果电压高于5V不建议使用该电路，比较危险。高电压采集最好需要一些专用的采集芯片，比如隔离放大器。



# DMA

# （一）简介

- DMA (Direct Memory Access)直 接存储器存取
- DMA可以提供**外设和存储器**或者**存储器和存储器之间**的高速数据传输，无须CPU干预，节省了CPU的资源
- 12个独立可配置的通道: DMA1 (7个通道)，DMA2 (5个通道)，每个通道都支持**软件触发（**存储器间的**）**和特定的**硬件触发（**外设到存储器间**）。**

STM32F103C8T6 DMA资源：DMA1 (7个通道)

**存储器映像**

| **类型** | **起始地址** | **存储器**      | **用途**                         |
| -------- | ------------ | --------------- | -------------------------------- |
| ROM      | 0x0800 0000  | 程序存储器Flash | 存储C语言编译后的程序代码        |
|          | 0x1FFF F000  | 系统存储器      | 存储BootLoader，用于串口下载     |
|          | 0x1FFF F800  | 选项字节        | 存储一些独立于程序代码的配置参数 |
| RAM      | 0x2000 0000  | 运行内存SRAM    | 存储运行过程中的临时变量         |
|          | 0x4000 0000  | 外设寄存器      | 存储各个外设的配置参数           |
|          | 0xE000 0000  | 内核外设寄存器  | 存储内核各个外设的配置参数       |

- **计算机组成部分：**运算器，控制器，存储器，输入输出设备
- CPU：运算器，控制器
- 存储器：主要是存储器的**内容和地址**
- ROM：只读存储器，掉电不丢失数据
- RAM：随机存储器，掉电丢失数据

其中系统存储器数据为厂家固定的启动加载程序，不修改。选项字节，在下载的时候可以不刷新其内容，保持不变，主要存的是flash读写保护、看门狗等配置。



## （二）原理

### 1、DMA框图

CPU+存储器两大部分

![1744190878111](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744190878111.png)

**寄存器：**是一种特殊存储器，一方面可以和存储器一样读写内容，另一方面，寄存器每一位背后都连接了一根导线，可以用于控制外设的状态。因此**寄存器是连接软件和硬件的桥梁**。软件读写寄存器从而控制硬件执行。即**外设是寄存器，寄存器就是存储器**。

如上图可看到DMA有三个，以太网DMA是自带的不用理会，剩下的DMA1和DMA2只要配置转移数据的源地址和目标地址就可以各自独立的工作了。其中有个**仲裁器**，这是因为虽然多个通道可以独立转运数据，但是DMA总线只有一条，因此只能分时复用这一条DMA总线，如果产生了冲突会使用仲裁器。另外再总线矩阵里也有一个仲裁器，如果DMA和CPU同时访问目标，**那么DMA就会暂停CPU的访问，**防止冲突，**此时仲裁器执行循环调度，以保证CPU至少可以得到一般的系统总线（存储器或外设）带宽**。

**AHB从设备：**DMA作为外设的寄存器，其连接在AHB总线上。所以DMA即是总线矩阵的主动单元，可以读写各种存储器，也是AHB总线上的被动单元，CPU通过这一条路线，就可以对DMA进行**参数配置**了。

**DMA请求：**由触发源（外设）发起，即**DMA的硬件触发源**。收到请求后之后DMA就可以进行数据转运了。

其中Flash是ROM，只读存储器的一种，如果通过CPU或者DMA都是**只能读取，不能写入**，因此不能用作DMA目的地址。想要写入需要配置这个Flash接口控制器，对Flash进行写入，流程比较麻烦。SRAM可以随意读写，外设寄存器需要参考手册描述，一般数据寄存器可以正常读写。

### 2、DMA基本结构

![1744190949681](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744190949681.png)

外设存储器地址可以是别的，也可以是自身相对的地址。
当传输计数器等于0时，且没有启动重装时，无论是否触发，DMA是不会运转的。此时只能先关闭DMA（必须），再对传输计数器写入一个大于0的值。

### 3、DMA请求

![1744190977974](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744190977974.png)

图中EN位表示通道是否工作；M2M位=1时候选择软件触发。

软件触发是任意的，而**每个通道的硬件触发源不同**。

### 4、数据宽度与对齐

作用：每个数据转运的站点都有数据宽度的参数描述，如果宽度一样，就正常处理，如果不一样就会使用到如下表格。

![1744191040464](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744191040464.png)

即，当数据宽度不统一时候，（小转大）可以在高位补0/（大转小）把多出来的高位舍弃掉不写入。传输数目是搬了4个数据，B1、B2等是数据，其/前面的是地址。

### 5、数据转运操作描述

==**传输方向**：存储器——存储器==

![1744191113643](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744191113643.png)

转运规定的次数7后，传输计数器自减到0，DMA停止，转运完成。
转运是==<u>复制转运</u>==，DataA[x]的数据并不会消失，会一直有数据。



==**传输方向：**外设——存储器==

![1744191192058](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744191192058.png)

触发一次AD，7个通道依次进行转换，再每个通道转换完成后，进行一次**DMA**数据转运，并且目的地址自行自增，这样就不会覆盖了。
即**==DMA配置==**：外设地址写ADC_DR寄存器地址，不自增；存储器地址可以自行创建数组来使用（**注意数据寄存器的宽度**，设置为一致），并且设置**自增**。转运计数器为7，**代表转运次数**。
计数器是否重装，可以看ADC配置，**如果是单次扫描，DMA的传输计数器可以不自动重装；如果是连续扫描，那DMA就可以使用自动重装**，在ADC启动下一轮转换的时候，DMA也启动下一轮转运。
ADC_DR的值是在ADC单个通道转换完成后才会有效，因此DMA转运时机，需要和ADC单个通道转换完成同步。所以DMA的触发选择要选**ADC的硬件触发**。
因为ADC转换完成后没有任何标志位，也不会触发中断，所以不好判断某个通道转换完成的时机。根据视频老师的实践，虽然==**单个ADC通道**==转换完成后不产生标志位和中断，**但是应该会产生DMA请求去触发DMA搬运**。ADC+DMA弥补了ADC数据覆盖的缺陷，天作之合。



# USART通信

# 通信接口了解

- **通信的目的︰**将一个设备的数据传送到另一个设备，扩展硬件系统

- **通信协议︰**制定通信的规则，**通信双方按照协议规则进行数据收发**

  | **名称** | **引脚**             | **双工** | **时钟** | **电平** | **设备** |
  | -------- | -------------------- | -------- | -------- | -------- | -------- |
  | USART    | TX、RX               | 全双工   | 异步     | 单端     | 点对点   |
  | I2C      | SCL、SDA             | 半双工   | 同步     | 单端     | 多设备   |
  | SPI      | SCLK、MOSI、MISO、CS | 全双工   | 同步     | 单端     | 多设备   |
  | CAN      | CAN_H、CAN_L         | 半双工   | 异步     | 差分     | 多设备   |
  | USB      | DP、DM               | 半双工   | 异步     | 差分     | 点对点   |

同步需要时钟线来保证传输数据不冲突。



# （一）串口通讯协议

### 1、简介

串口是一种应用十分广泛的通讯接口，串口成本低、容易使用、通信线路简单，可实现两个设备的互相通信。单片机的串口可以使单片机与单片机、单片机与电脑、单片机与各式各样的模块互相通信，极大地扩展了单片机的应用范围，增强了单片机系统的硬件实力。

![1744191445923](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744191445923.png)

### 2、硬件电路

- 简单双向串口通信有两根通信线(发送端TX和接收端RX)

- TX与RX要交叉连接

- **当只需单向的数据传输时，可以只接一根通信线**

- 当电平标准不一致时，需要加电平转换芯片

  ![1744191490439](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744191490439.png)

**因为TX/RX的高低电平是相对于GND来说的，所以这三根都是通讯线，双向通信必须要连接的。**VCC则看设备双方是否都有供电而考虑。

==**【电平标准】**==
电平标准是数据1和数据0的表达方式，是传输线缆中人为规定的电压与数据的对应关系，串口常用的电平标准有如下三种︰
TTL电平：+3.3V或+5V表示1，OV表示0
RS232电平（大机器）：-3~-15V表示1，+3~+15V表示0
RS485电平：两线压差+2~+6V表示1，-2~-6V表示0（差分信号）抗干扰（可达上千米）

### 3、串口参数及时序

- **波特率∶**串口通信的速率（<u>决定每隔多久发送一位</u>）
- **起始位︰**标志一个数据帧的开始，固定为低电平
- **数据位︰**数据帧的有效载荷，1为高电平。0为低电平，低位先行
- **校验位︰**用于数据验证，根据数据位计算得来
- **停止位︰**用于数据帧间隔，固定为高电平![1744191583609](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744191583609.png)

左侧为无校验，右侧为1位校验

**校验方式：****奇偶校验、和校验、CRC校验、LRC校验.....**

**【时序波形】**

![1744197156773](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744197156773.png)



## (二) USART外设

### 1、USART简介

● UART：universal asynchronous receiver and transmitter通用异步收/发器
●USART： (Universal Synchronous/Asynchronous Receiver/Transmitter）通用同步/**异步收发器**
==**注：**==这里的同步模式，多了一个仅支持输出的时钟，是兼容别的协议或者特殊用途而设计；不支持两个USART之间进行同步通信。因此主要还是学习异步通信。
●USART是STM32内部集成的硬件外设，可根据数据寄存器的一个字节数据自动生成数据帧时序，从TX引脚发送出去，也可自动接收RX引脚的数据帧时序，**拼接为一个字节数据**，存放在数据寄存器里。
●自带波特率发生器，最高达4.5Mbits/s
●**可配置参数**：数据位长度(8/9)、停止位长度(0.5/1/1.5/2)，即间隔
●可选校验位（**==无校验==**/奇校验/偶校验)
●支持同步模式、**硬件流控制**、DMA、智能卡、IrDA（红外通信）、LIN（局域网通信协议）
**【硬件流控制】**如果数据发送得过快来不及接收，那么就可以通过这个来控制USART处于可收发的状态，一般不用。
●STM32F103C8T6 USART资源：USART1、USART2、USART3
**注意**：开启时钟时候注意挂载的总线

### 2、USART框图

![1744197377173](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744197377173.png)

主要关注TX/RX引脚，一个发送一个接收。
DR寄存器：占用同一个地址，但是硬件上是两个寄存器，TDR发送数据寄存器、RDR接收数据寄存器。
移位寄存器：一个发送，从寄存器转移（低位往高位发送）；一个接收，转移到寄存器（高位往低位接收）。通过标志位进行判断数据接收/发送完成。
发送接收器控制：
硬件数据流控：了解
SCK输出：用于兼容其他协议。
唤醒单元：串口实现挂载多设备，可以给串口分配一个地址，当发送制定地址时，此设备唤醒开始工作。当你发送别的设备地址时，别的设备就唤醒工作，没收到的就保持沉默。
 中断申请位：就是**状态寄存器**这里的各种标志位，标志位的TXE发送寄存器空，RXNE接收寄存器**非空**，是判断发送和接收状态的**必要标志位**。
**USART中断控制**：配置中断是不是能通向NVIC
波特率发生器：分频器，APB时钟进行分频，得到发送和接收移位的时钟。

### 3、USART基本结构

发送接收引脚是GPIO的复用输出，开发时候，如果硬工没给你画好，则需要注意引脚的划分，避免冲突。

![1744197466812](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744197466812.png)

发送接收移位寄存器硬件上看着有四个，但实际软件成眠只有一个DR寄存器供我们读写。



## （三）数据帧解析

### 1、字长设置

![1744197544330](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744197544330.png)

有效载荷保持1字节，会比较的...使强迫症情绪稳定。

### 2、配置停止位（不常用）

![1744197568878](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744197568878.png)

### 3、USART输入数据策略

**起始位侦测：**数据采样位置对齐正中间

![1744197616227](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744197616227.png)

**注意：** 如果该序列不完整，那么接收端将退出起始位侦测并回到空闲状态**(**不设置标志位**)**等待下降沿。 

如果**3**个采样点都为**’0’(**在第**3**、**5**、**7**位的第一次采样，和在第**8**、**9**、**10**的第二次采样都为**’0’)**， 

则确认收到起始位，这时设置**RXNE**标志位，如果**RXNEIE=1**，则产生中断。 

如果两次**3**个采样点上仅有**2**个是**’0’(**第**3**、**5**、**7**位的采样点和第**8**、**9**、**10**位的采样点**)**，那么起始 

位仍然是有效的，但是会设置**NE**噪声标志位。如果不能满足这个条件，则中止起始位的侦测过 

程，接收器会回到空闲状态**(**不设置标志位**)**。 

如果有一次**3**个采样点上仅有**2**个是**’0’(**第**3**、**5**、**7**位的采样点或第**8**、**9**、**10**位的采样点**)**，那么起 

始位仍然是有效的，但是会设置**NE**噪声标志位。



**数据采样流程：**可以对噪声进行判断，三次采样规则（全一致，采样电平不同，则按次数最多的考虑），但凡有不一致的就置位NE，代表有噪声。

![1744197726253](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744197726253.png)

### 4、波特率发生器

发送器和接收器的波特率由波特率寄存器BRR里的DIV确定

**计算公式：**
$$
波特率= fPCLK2/1 / (16 * DIV)
$$
![img](https://cdn.nlark.com/yuque/0/2024/png/25954489/1712128613795-ac545a14-ce56-4d6a-8264-de01e13b41c3.png)

### 5、CH340模块

发送器和接收器的波特率由波特率寄存器BRR里的DIV确定

**计算公式：**波特率= fPCLkK2/1/(16*DIV)

![img](https://cdn.nlark.com/yuque/0/2024/png/25954489/1712128613795-ac545a14-ce56-4d6a-8264-de01e13b41c3.png)



## （四）USART串口数据包

### 1、HEX数据包

数据包的作用？
把一个个单独的数据打包起来，方便进行多字节通讯。打包的方式可以是自己设定，也可以是别开发者规定，即**自拟通讯协议**。根据协议规则（掐包头包尾）在连续不断接收的数据流中提取出需要的数据。

- **固定包长，含包头包尾（课程自拟）**

![1744198118930](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744198118930.png)

- **可变包长，含包头包尾**

![1744198129301](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744198129301.png)

**若数据位和包头包尾重复**
基础解决方案：①限制载荷数据的范围，在范围内即为正常数据。②尽量使用固定包长，即规定有效数据长度，对齐后用于接收后判断提取。③增加包头包尾的字节数量，多次判断，好确定是包头。....（工作中还有其他方式，可自行学习）
**固定包长和可变包长如何选择**
如果载荷数据会跟包头包尾重复，则固定长度比较合适。不重复就选可变。

### 2、文本数据包

**说明：**HEX数据包本身就是以原始的字节数据本身呈现的字节流，而文本数据包里面，每个字节就多了一层编码和译码，最终呈现出来的就是文本格式。虽然背后还是字节数据，这就存在**独特的字符**，可以有效避免数据载荷和包头包尾重复的问题。
**缺点：**解析效率低，需要根据使用场景来使用。

- **固定包长，含包头包尾**

![1744198282659](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744198282659.png)

- **可变包长，含包头包尾**

  ![1744198316368](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744198316368.png)

### 3、数据包接收

发送比较简单，接收比较复杂，因此复杂内容较值得讨论。接收逻辑通用。

**固定包长，HEX数据包接收**

![1744198368224](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744198368224.png)

**可变包长，文本数据接收**

![1744198428888](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744198428888.png)

使用状态机用于表示标志位再接受过程中的状态变化，用于判断不同情况，根据这些状态执行不同的操作代码。比如开始接收到一个字节，进入中断，此时状态还没有接收到包头=0，就需要先判断是不是包头，而不判断其他。就这样一个字节一个字节的判断，终于拿到了完整的包头，状态就发生了改变=1，这时候再接收到一个字节，直接就保存接收后面固定长度的内容。



# I2C通讯

## （一）简介

- I2C总线(InterIC BUS)是由Philips公司开发的一种通用数据总线
- **两根通信线：**SCL(SerialClock)、SDA(Serial Data)
- 同步，半双工
- 带数据应答
- 支持总线挂载多设备(一主多从、多主多从)

![1744198535180](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744198535180.png)

串口有USART硬件电路支持，异步通讯才比较稳定，但是软件模拟比较复杂。I2C因为是同步协议，软件模拟起来非常容易。**使用同步时序就可以极大地降低单片机对硬件电路的依赖。**即使没有硬件，也可以通过软件的引脚反转电平来实现时钟控制。而单片机去干别的事情的事就可以中断时钟线，这样设备也会停止接收，减少数据错误的可能。
异步通信就是省一根时钟线，对时间要求严格，对硬件电路的依赖比较严重。同步通讯则相反。
**一般使用一主多从的模式：**类似一个老师讲课，很多学生听课，学生只能被老师点名后才可以发言。



## （二）硬件电路

- 所有I2C设备的SCL连在一起，SDA连在一起
- 设备的SCL和SDA均要配置成开漏输出模式
- SCL和SDA各添加一个上拉电阻，阻值一般为4.7K左右

![1744198610498](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744198610498.png)

左侧为I2C经典电路：一主多从，右侧为引脚的内部结构。

主机对SCL线具有完全控制功能，空闲时候主机控制SDA，只有从机发送数据或从机应答的时候，主机才会转交SDA的控制权给从机。
**为了防止电平没协调好而起冲突，I2C设计禁止了所有设备输出强上拉的高电平，采用外置弱上拉电阻加开漏输出的电路结构**
**即只允许向下拉或者松手，有电阻弹簧会自动拉高（弱上拉）。**
**【好处】：**
①完全杜绝了电源短路现象，保证电路的安全，防止同时被强拉或推的状态，即使多个根下拉杆子饿么有问题。
②避免了引脚模式的频繁切换，开漏加弱上拉的模式，同时兼具了输入和输出的功能。想输出就拉杆子放手，操作杆子变化，观察即可得到电平。因为开漏模式下，输出高电平就相当于断开引脚，所有在输入之前，可以直接输出高电平，不需要切换成输入模式。
③模式会有一个线与的现象，只要有任意一个或多个设备输出了低电平，总线就处于低电平；所有设备输出高电平（放手）才处于高电平。I2C可以利用电路特征，执行多主机模式下的时钟同步和总线仲裁。



## （三）I2C时序基本单元

- **起始条件：**SCL高电平期间，SDA从高电平切换到低电平
- **终止条件：**SCL高电平期间，SDA从低电平切换到高电平

![1744198739227](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744198739227.png)

起始和终止条件都是由主机产生的，所有在总线空闲状态时，从机必须始终双手放开，不允许碰（如果触碰了就是多主机模式了）。

- **发送一个字节：**SCL低电平期间，主机将数据位依次放到SDA线上**（高位先行）**，然后释放SCL，从机将在SCL高电平期间读取数据位所以==**SCL高电平期间SDA不允许有数据变化**==，依次**循环**上述过程**8次**即可发送一个字节

[^发送一个字节]: 主机先改变SDA再改变SCL，循环8次即发送一个字节

![1744198773428](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744198773428.png)

一般上升沿时刻从机就已经读取完了。

●   **接收一个字节**：SCL低电平期间，从机将数据位依次放到SDA线上**（高位先行）**，然后释放SCL，主机将在SCL高电平期间读取数据位所以SCL高电平期间SDA不允许有数据变化，依次循环上述过程8次即可接收一个字节（**主机在接收之前，需要释放SDA**，让发送从机控制）

![1744198905874](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744198905874.png)

从机的数据变换贴着SCL下降沿，因为接受到SCL上升沿后需要响应时间。

- **发送应答：**主机在接收完一个字节之后，在下一个时钟**发送一位数据**，数据0表示应答，数据1表示非应答
- **接收应答：**主机在发送完一个字节之后，在下一个时钟**接收一位数据**，判断从机是否应答，数据0表示应答，数据1表示非应答（主机在接收之前，需要释放SDA）

[^应答]: 字节与字节收发之间的应答

![1744198927540](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744198927540.png)



## （四）I2C时序

### 1、指定地址写

主机要确定访问的设备，就需要把每个从机都确定一个唯一的设备地址，从机设备地址就是名字。而主机发送前会叫一下这个名字，所有从机都会收到，但只有匹配的从机才进行响应读写操作。

【从机设备地址】在I2C标准里分为7位和10位地址，**教程讲7位，因为比较简单和应用范围广。**在每个设备出厂时候就会会被分配一个地址。具体可以在芯片手册里找到。相同型号的地址一般都是一样的地址。如果多个相同型号都挂在总线上。就需要用到**地址中的可变部分**来进行区分。

- **对于指定设备（Slave Address），在指定地址（Reg Address）下，写入指定数据（Data）**

[^]: 起始+从机地址+从应答+数据+从应答+...+结束

![1744199000013](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744199000013.png)

### 2、当前地址读

- 对于指定设备（Slave Address），**在当前地址指针指示的地址下，读取从机数据（Data）**

此时传输数据并没有指定写入从机的寄存器地址，因此需要用到地址指针。会自动增加地址写入。

![1744199083052](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744199083052.png)

[^]: 起始+从地址+应答+数据+应答+停止

### 3、指定地址写入

对于指定设备（Slave Address），在指定地址（Reg Address）下，读取从机数据（Data）

需要在指定地址写的从机地址时序部分后+当前地址读的时序，从而得到。

![1744199118627](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744199118627.png)

如果想发多个数据，只需要将数据部分重复即可，即在指定地址输入后，写入多个字节，地址会自增。注意这时候主机如果想要结束数据，就需要在最后一个数据结束后加上非应答，否则会让从机认为主机还需要数据，从机继续发生下一个数据，从而占据SDA，主机想产生停止条件就不能正常回答高电平了。



# I2C外设

# （一）简介

- STM32内部集成了硬件I2C收发电路，可以由**硬件自动执行**时钟生成、起始终止条件生成、应答位收发、数据收发等功能，**减轻CPU的负担**
- 支持多主机模型
- 支持7位/10位地址模式
- 支持不同的通讯速度，**标准速度(高达100 kHz)，快速(高达400 kHz)**
- 支持DMA
- 兼容SMBus（System Managerment Bus主要用于电源管理系统）协议
- STM32F103C8T6 硬件I2C资源**（硬件I2C受限于资源）**：I2C1、I2C2

软件模拟I2C是非常常见的，但是作为一个协议标准，I2C通讯也是可以有硬件收发电路的。**如果是简单应用，那么软件模拟会比较灵活，如果要求性能指标要求比较高，就考虑硬件I2C**。本小结讲硬件STM32内部的I2C外设。

多主机模式下，两个主机同时通讯占用总线就要发起总线仲裁。可变多主机模式，所有设备一视同仁，谁想当主机谁就站出来。

关于I2C地址，可以通过**修改低位可变地址部分**来避免地址冲突，也可以另外再开辟I2C总线，比较容易解决。而STM32支持10位地址，1024种可能。在实现中，剩下的5位地址会用作标志位。

## （二）I2C框图

![1744199217994](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744199217994.png)

**核心部分是数据寄存器和移位寄存器：**

- 当我们需要发送数据时，可以把一个字节数据写到数据寄存器DR，这个数据寄存器的值就会进一步转到移位寄存器里，在移位的过程中，就可以把下一个数据放到数据寄存器里等着了，一但前一个数据移位完成，下一个数据就可以无缝衔接，继续发送。其中数据寄存器转到移位寄存器时候，就会置状态寄存器的TXE位为1，表示**发送数据寄存器**为空。
- 当我们需要接收时候，也是输入的数据一位一位的，从引脚移入到移位寄存器里，当一个字数据具收齐后，数据整体从移位寄存器转移到数据寄存器，同时置标志位RXNE，表示**接收数据寄存器**非空。这时候就可以把数据读出来了。

## （三）I2C基本结构

![1744199250707](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744199250707.png)



## （四）硬件I2C操作流程

### 1、主机发送

![1744199294904](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744199294904.png)

7位地址起始条件后的**一个字节是寻址**，10位地址起始条件后的**两个字节都是寻址**。后续的数据可以由厂商规定。

STM32默认从模式，将硬件标志位置位，会因此转成主模式，表示有数据要发。之后软件检查EV5标志位（EVx标志位是组合了多个标志位的大标志位），看硬件是否都达到了想要的状态。

### 2、主机接收

![1744199323341](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744199323341.png)



## （五）软硬件波形对比

![1744199354152](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744199354152.png)

[^波形对比]: 上下分别为软件、硬件



# SPI通讯

## （一）简介

- SPI（Serial Peripheral Interface）是由Motorola公司开发的一种通用数据总线
- **四根通信线：**SCK（Serial Clock）、MOSI（Master Output Slave Input）、MISO（Master Input Slave Output）、SS（Slave Select）。名称会有不同，注意对照芯片手册即可。
- 同步，全双工
- 支持总线挂载多设备**==（仅一主多从），会有多根SS线==**

![1744199431320](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744199431320.png)

比较之前学习的I2C还是比较复杂的，地址限制下多设备都只需要两根线。但是其通讯线高电平驱动能力比较弱，这会导致上升沿的过程耗时长，限制通讯速度100、400KHz。**相对于I2C，SPI的优缺点：**

①SPI协议并没有严格规定最大传输速度，其取决于芯片厂商需求。

②SPI比较简单，没有I2C那么多功能。

③全双工，SPI硬件开销大，通讯过程中经常会有资源库浪费现象。有钱！就是要快速。



## （二）硬件电路

- 所有SPI设备的SCK、MOSI、MISO分别连在一起

- - **SCK：**时钟线完全由主机掌控，主机输出，从机输入。
  - MOSI：主机输出，从机输入
  - MISO：主机输入**（看图中箭头）**，从机输出

- 主机另外引出**多条SS控制线**，分别接到各从机的SS引脚
- 输出引脚配置为推挽输出，输入引脚配置为浮空或上拉输入

![1744199467543](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744199467543.png)

![img](https://cdn.nlark.com/yuque/0/2024/png/25954489/1713491289906-4ceff14e-6038-4456-9f5c-bd9102901f1f.png?x-oss-process=image%2Fcrop%2Cx_38%2Cy_40%2Cw_862%2Ch_483)

SPI的输入输出引脚是固定的，基本不会出现冲突，因此可以使用推挽输出。但SPI仍有可能在MISO线上多个从机推挽输出造成冲突，因此**SPI规定从机未被选中时候的MISO引脚必须为高阻态**，当然写主机程序不需要关注从机这个问题。



## （三）移位示意图

移位寄存器随着SCK的频率**触发移位**，会将箭头方向**移出**去的一位**放到引脚上**。在SCK频率触发的**间隔**，主机和从机都进行数据采集，**获取**移除位所在的引脚的电平存放到各自箭头方向连接的寄存器上。

![1744199570342](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744199570342.png)

多次后就完成了==**一个字节的数据交换**==。只收或只发的情况下，只需要忽略掉发送或者接收信号即可。



## （四）SPI时序基本单元

- 起始条件：SS从高电平切换到低电平
- 终止条件：SS从低电平切换到高电平

![1744199628564](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744199628564.png)

交换数据过程，SPI并没偶有规定在SCK的什么时候进行移位，给了开发者配置的选择，兼容更多芯片。==**有两个可以配置的位，提高协议<u>兼容性</u>，产生了如下四种模式：模式虽然多，功能相似，只学习一种即可**==。

**【交换一个字节（模式0）】**

- （时钟极性）CPOL=0：空闲状态时，SCK为低电平
- （时钟相位）CPHA=0：**SCK第一个边沿移入数据**，第二个边沿移出数据

![1744199701503](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744199701503.png)

MISO不发送数据时候为高阻态（中间线），只要SS不置高，可以一致重复交换数据。

**【交换一个字节（模式1）】==（常用、高速）==**

- CPOL=0：空闲状态时，SCK为低电平
- CPHA=1：**SCK第一个边沿移出数据**，第二个边沿移入数据

![1744199737320](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744199737320.png)

【交换一个字节（模式2）】

- CPOL=1：空闲状态时，SCK为高电平
- CPHA=0：SCK第一个边沿移入数据，第二个边沿移出数据

![1744199756526](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744199756526.png)

【交换一个字节（模式3）】

- CPOL=1：空闲状态时，SCK为高电平
- CPHA=1：SCK第一个边沿移出数据，第二个边沿移入数据

![1744199780019](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744199780019.png)



## （五）SPI时序

### 1、发送指令

在I2C中使用的是读写寄存器的模型（地址+数据），而SPI通常采用指令码加读写数据的模型（指令码+数据）。

[^模式0]: W24Q64时序例子：向SS指定的设备，发送指令（0x06）

![1744199835346](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744199835346.png)

### 2、指定地址写

向SS指定的设备，发送**写指令（0x02）**，随后在指定地址（**Address[23:0]**）下，写入指定数据（Data）

[^W25Q64]: 写

![1744199988648](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744199988648.png)

W25Q64规定写指令之后的字节定义为地址高位

### 3、指定地址读

向SS指定的设备，发送**读指令（0x03）**，随后在指定地址（Address[23:0]）下，读取从机数据（Data）

[^W25Q64]: 读

![1744200034332](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744200034332.png)

因为要读取数据，所以在指令码（0x03）+地址（0x123456）之后随便给从机一个数据，一般给0xFF，这时从机就会把0x123456地址下的数据通过MISO发给主机。如果主机继续发送数据，从机地址指针自动+1，就可以获取下一个地址的数据，实现多个地址接收。



## （六）W25Q64

### 1、简介

- W25Qxx系列是一种低成本、小型化、使用简单的**非易失性存储器**，常应用于数据存储、**字库存储**、固件程序存储等场景
- 存储介质：Nor Flash（闪存）
- 时钟频率：80MHz / 160MHz (Dual SPI) / 320MHz (Quad SPI两根线同时运行，一个时钟发两位)
- **存储容量（24位地址）**：==（最大寻址空间16M，更大需要进入4字节模式）==

![1744200122674](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744200122674.png)

W25Q40：    4Mbit / 512KByte

  W25Q80：    8Mbit / 1MByte

  W25Q16：    16Mbit / 2MByte

  W25Q32：    32Mbit / 4MByte

  W25Q64：    64Mbit / 8MByte

  W25Q128：  128Mbit / 16MByte

  W25Q256：256Mbit  / 32MByte

### 2、硬件电路

![1744200189689](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744200189689.png)

![1744200213088](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744200213088.png)

| **引脚**   | **功能**            |
| ---------- | ------------------- |
| VCC、GND   | 电源（2.7~3.6V）    |
| CS（SS）   | SPI片选             |
| CLK（SCK） | SPI时钟             |
| DI（MOSI） | SPI主机输出从机输入 |
| DO（MISO） | SPI主机输入从机输出 |
| WP         | 写保护              |
| HOLD       | 数据保持            |

### 3、W25Q64框图

![1744200236974](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744200236974.png)

容量8M,太大了，需要划分。存储器以字节为单位，每个字节都有唯一的地址。之前说W25Q64的地址宽度位24位=3个字节，寻址范围是16M，但这个芯片我们只用了一半，即如图从000000**h**~7FFFFF**h**

（弹幕：8MB的空间中包含的字节总数为8 * 1024 * 1024 = 8388608个字节。在计算机中，通常使用0作为起始值来表示第一个字节，因此最后一个字节的地址将是总字节数减去1。）

在0h~7FFFFFh的空间里，以**64KB**为一个基本单元，划分为若干个**Block**，共128块（0~127）。继续将单个块划分为多个**Sector**，一个扇区**4KB**，即16扇区（0~15）/块。当然还可以**对整个存储器进行更细致的划分，**划分为**Page，可以理解为在扇区中继续划分页数**，以**256B**为单位，相当于16页/扇，

SPI控制寄存器上方连接着一个状态寄存器，用于知晓芯片是否忙、是否写使能、写保护。

High Voltage Generators：因为这是掉电不丢失的存储器，内部需要有高压源来把数据狠狠的写入。

图中的两个锁存计数器，用于处理我们发送的3字节地址。高位的2字节会进入到页地址锁存计数器里。低位字节会进入到字节锁存计数器里。然后页地址——行解码；字节地址——列解码，就可以找到地址；因为是计数器，因此读写操作完成后地址会自动+1；

256B的缓存大小。

**==【Flash操作注意事项】==**

- **写入操作时：**（牢记）

- - 写入操作前，必须先进行写使能**（先解锁再操作，防止数据乱）**
  - 每个数据位只能由1改写为0，不能由0改写为1（**不像RAM那样有覆盖改写的能力，成本技术原因，因此需要下一条规定先擦除）**
  - 写入数据前必须先擦除，擦除后，所有数据位变为1
  - 擦除必须**按最小擦除单元**进行
  - 连续写入多字节时，**最多写入一页的数据==（因为页缓存区只有这么多）==**，超过页尾位置的数据，会回到页首覆盖写入
  - 写入操作结束后，芯片**进入忙状态**，不响应新的读写操作

- **读取操作时：**

- - 直接调用读取时序，无需使能，无需额外操作，没有页的限制，读取操作结束后不会进入忙状态，但不能在忙状态时读取



# SPI外设

## （一）SPI外设简介

- STM32内部集成了硬件SPI收发电路，可以由硬件自动执行时钟生成、数据收发等功能，减轻CPU的负担
- 可配置**8位**/16位数据帧（用得少）、**高位先行（SPI基本都是）**/低位先行**==（串口是低位先行）==**
- 时钟频率： fPCLK / (2, 4, 8, 16, 32, 64, 128, 256)
- 支持多主机模型、主或从操作
- 可精简为半双工/单工通信
- 支持DMA
- 兼容I2S协议（音频传输协议）
- STM32F103C8T6 硬件SPI资源：SPI1（72MHz）、SPI2（36MHz）



## （二）SPI框图

![1744200371372](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744200371372.png)

MOSI和MISO引脚交叉连接部分，用于引脚变化的，用于主从机切换，只当主机时就不用管了。**其中箭头错误已更改**。移位寄存器参考先前的**移位示意图**的内容。



## （三）SPI基本结构

![1744200415131](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744200415131.png)

框图缺少SS，这个引脚使用普通GPIO来模拟即可。



## （四）主模式传输操作

### 1、全双工连续传输

[^SPI模式3连续传输时序说明]: 如果对传输效率有要求可以研究

![1744200471102](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744200471102.png)

### 2、非连续传输

![1744200510662](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744200510662.png)

**【区别】：**当TXE置1后，第一个字节写入TDR，等待传输**第一个字节时序结束**，即接收完成，这时RXNE会置1，然后把第一个接受到的数据从RDR读出来**==（较晚写入的原因）==**，之后再写入下一个字节数据。

**【总结】：**

==**①**等待TXE置1。**②**写入TDR数据。**③**等待RXNE置1。**④**读取RDR数据==

继续循环等待TXE...再写入TDR数据.....将这4步骤封装成一个函数，掉一次写入一个字节，实现起来就非常简单。

**【缺点】：**在TXE置1的位置，没有及时把下一个数据写入TDR等候着，当读取数据完成后，下一个字节数据还没有传输，就会使得**字节与字节之间**有等待间隙。慢的时钟速度下不明显，但一快起来就明显拖慢。

![image.png](https://cdn.nlark.com/yuque/0/2024/png/25954489/1713514783672-1856fadf-f0b6-4a9a-b640-0459d5f0f490.png?x-oss-process=image%2Fformat%2Cwebp)

![image.png](https://cdn.nlark.com/yuque/0/2024/png/25954489/1713514909266-89ef990b-0f9e-4cb0-be70-127d3f810ff3.png?x-oss-process=image%2Fformat%2Cwebp)

因此在追求最高性能的，还是使用连续传输操作逻辑或者进一步采用DMA转运。



## （五）软硬件波形对比

[^波形]: 上下分别为软件、硬件

![1744200618691](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744200618691.png)



# RTC外设

## （一）简介

- RTC(Real Time Clock)实时时钟

- RTC是一个独立的定时器，可为系统**提供时钟和日历**的功能

- RTC和时钟配置系统处于后备区域，**系统复位时数据不清零，**VDD(2.0~3.6V)断电后可借助VBAT(1.8~3.6V)供电继续走时

- 32位的可编程计数器，可对应**Unix时间戳的秒计数器**

  > •Unix 时间戳（Unix Timestamp）定义为从UTC/GMT的1970年1月1日0时0分0秒开始所经过的秒数，不考虑闰秒
  >
  > •时间戳存储在一个秒计数器中，秒计数器为32位/64位的整型变量
  >
  > •世界上所有时区的秒计数器相同，不同时区通过添加偏移来得到当地时间
  >
  > •C语言的time.h模块提供了时间获取和时间戳转换的相关函数，可以方便地进行秒计数器、日期时间和字符串之间的转换
  >
  > | **函数**                                                     | **作用**                               |
  > | ------------------------------------------------------------ | -------------------------------------- |
  > | time_t time(time_t*);                                        | 获取系统时钟                           |
  > | struct tm* gmtime(const time_t*);                            | 秒计数器转换为日期时间（格林尼治时间） |
  > | struct tm* localtime(const time_t*);                         | 秒计数器转换为日期时间（当地时间）     |
  > | time_t mktime(struct tm*);                                   | 日期时间转换为秒计数器（当地时间）     |
  > | char* ctime(const time_t*);                                  | 秒计数器转换为字符串（默认格式）       |
  > | char* asctime(const struct tm*);                             | 日期时间转换为字符串（默认格式）       |
  > | size_t strftime(char*, size_t, const   char*, const struct tm*); | 日期时间转换为字符串（自定义格式）     |

- 20位的可编程预分频器，可适配不同频率的输入时钟（确保给到计数器的是1Hz的频率）

- **可选择三种RTC时钟源：****（LSE主要就是供RTC的，只有这一路时钟可以通过VBAT备用电池供电，上下两路用于特殊情况备选）**

- - HSE时钟除以128(通常为8MHz/128)
  - LSE振荡器时钟(通常为32.768KHz)**——计算比较方便2^15=32768****（设计一个15位计数器，即可1秒自然溢出一次，目前RTC实时时钟常用该晶振）**
  - LSI振荡器时钟(40KHz)

（压力不会消失，只会转移，能吃苦就有吃不完的苦）



## （二）RTC框图

![1744200909665](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744200909665.png)

灰色部分都属于后备区



## （三）RTC基本结构

![1744200941409](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744200941409.png)



## （四）硬件电路

为了配合RCT外部还是需要一些电烤炉的，在最小系统板电路上，要加两部分，一电池，二外部低速晶振。

![1744200993176](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744200993176.png)



## （五）操作事项

- **执行以下操作将使能对BKP和RTC的访问：**

- - 设置RCC APB1ENR的PWREN和BKPEN，使能PWR和BKP时钟==**（同时开启）**==
  - 设置PWR CR的DBP，使能对BKP和RTC的访问

- 若在读取RTC寄存器时，RTC的APB1接口曾经处于禁止状态，则软件首先必须等待RTC_CRL寄存器中的RSF位(寄存器同步标志)被硬件置1**（即调用一个==RTC等待同步函数==，等一下RTCCLK）**
- **必须设置RTC_CRL寄存器中的CNF位**，使RTC进入配置模式后，才能写入RTC PRL、RTC CNT、RTC ALR寄存器
- 对RTC任何寄存器的写操作，都必须在前一次**写操作结束后**进行可以通过查询RTC CR寄存器中的RTOFF状态位，判断RTC寄存器是否处于更新中。**仅当RTOFF状态位是1时，才可以写入RTC寄存器**



# PWR电源控制

## （一）简介

- PWR(Power Control)电源控制
- PWR负责管理STM32内部的电源供电部分，可以实现可编程电压监测器和低功耗模式的功能
- 可编程电压监测器(PVD)可以监控VDD电源电压，当VDD下降到PVD阀值以下或上升到PVD阀值之上时，PVD会触发中断，用于执行紧急关闭任务
- **==低功耗模式包括睡眠模式(Sleep)、停机模式(Stop)和待机模式(Standby)==**，可在系统**空闲时**，降低STM32的功耗，延长设备使用时间**（低功耗模式需要考虑关闭那些硬件，保留那些硬件，以及如何去唤醒，用关闭不同程度的硬件来区分不同模式）**



## （二）电源框图

![1744201311599](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744201311599.png)

核心供电靠1.8V运行，只要需要进行外设交流时候才通过IO电路转换到3.3V。



## （三）电压监测

![1744201379829](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744201379829.png)

当VDD或VDDA电压过低时，内部电路直接产生复位，让STM32不要乱操作。

![1744201449187](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744201449187.png)

可以指定电压阈值，PVD中断是外部触发的。因为低功耗唤醒只有外部触发模式。



## （四）低功耗模式

### 1、简介

![1744201485480](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744201485480.png)

- 关闭电路通常有两种做法，一个是关闭时钟，一个是关闭电源。关闭时钟，所有的运算和设计时序的操作都会暂停，但是寄存器和存储器里面保存的数据还可以维持，不会消失。关闭电源，所有操作和数据都会丢失，更省电。
- 用**PDDS**标志位来区分是停机模式还是待机模式。
- **WFI**要用外部中断唤醒，**WFE**要用外部事件唤醒。**==（非常省电，需要外部敲醒）==**
- 待机模式需要指定信号唤醒！关闭状态严重，内部存储器数据和寄存器数据均丢失。**和停机模式一样，不会主动关闭LSI/LSE两个低速时钟，用于维持，RTC和IWDG看门狗。**

### 2、模式选择

执行Fl(Wait For Interrupt)或者WFE(Wait For Event)指令后STM32进入低功耗模式。

![1744201531112](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744201531112.png)

### 3、睡眠模式

- 执行完WFI/WFE指令后，STM32进入睡眠模式，程序暂停运行，唤醒后程序从暂停的地方继续运行
- SLEEPONEXIT位决定STM32执行完WFI或WFE后，是立刻进入睡眠还是等STM32从最低优先级的中断处理程序中退出时进入睡眠
- 在睡眠模式下，所有的1/0引脚都保持它们在运行模式时的状态
- WFI指令进入睡眠模式，可被任意一个NVIC响应的**中断唤醒**
- WFE指令进入睡眠模式，可被唤醒**事件唤醒**

### 4、停止模式

- 执行完WFI/WFE指令后，STM32进入停止模式，程序暂停运行，**唤醒后程序从暂停的地方继续运行**
- 1.8V供电区域的所有时钟都被停止，PLL、HSI和HSE被禁止，**SRAM和寄存器内容被保留下来**
- 在停止模式下，所有的**IO引脚都保持**它们在运行模式时的状态
- 当一个中断或唤醒事件导致**退出停止模式时，HSI被选为系统时钟==（因此第一时间要启动HSE，配置主频）==**
- 当电压调节器处于低功耗模式下，**系统从停止模式退出时，会有一段额外的启动延时**
- WFI指令进入停止模式，可被任意一个**EXTI中断唤醒**
- WFE指令进入停止模式，可被任意一个**EXTI事件唤醒**

### 5、待机模式

- 执行完WFI/WFE指令后，STM32进入待机模式，**唤醒后程序从头开始运行**
- 整个1.8V供电区域被断电，PLL、HSI和HSE也被断电，SRAM和寄存器内容丢失，只有备份的寄存器和待机电路维持供电
- 在待机模式下，所有的IO引脚变为**高阻态(浮空输入)**
- WKUP引脚的上升沿、RTC闹钟事件的上升沿、NRST引脚上外部复位、IWDG复位退出待机模式



# FLASH闪存

## （一）简介

- STM32F1系列的FLASH包含程序存储器、系统存储器和选项字节三个部分，通过**闪存存储器接口(外设)**可以对程序存储器和选项字节进行擦除和编程
- **读写FLASH的用途：**

- - 利用**程序存储器的剩余空间**来保存掉电不丢失的用户数据
  - 通过在程序中编程(IAP)，实现程序的自我更新

- 在线编程（In-Circuit Programming-ICP）用于更新程序存储器的全部内容它通过**JTAG、SWD**协议或系统加载程序（Bootloader）下载程序
- 在程序中编程(In-Application Programming-lAP)可以使用微控制器支持的任一种通信接口下载程序

## （二）闪存模块

![1744201779983](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744201779983.png)

闪存存储器借口寄存器为闪存的管理员，擦除和编程通过对这些寄存器操作来完成。而读取只需要使用指针直接读取即可。

## （三）Flash基本结构

![1744201807618](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744201807618.png)

整个闪存分为程序存储器、系统存储器、选项字节（配置读写保护）。



## （四）Flash操作

### 1、Flash解释

- **FPEC共有三个键值：（防止误操作）**

RDPRT键=0x000000A5

KEY1 = 0x45670123

KEY2 =0xCDEF89AB

- **解锁：**

复位后，FPEC被保护，不能写入FLASHCR

在FLASH_KEYR先写入KEY1，再写入KEY2，解锁

错误的操作序列会在下次复位前锁死FPEC和FLASHCR

- **加锁：**

设置FLASH CR中的LOCK位锁住FPEC和FLASHCR

### 2、使用指针访问存储器

- **使用指针读指定地址下的存储器：**（注意优先级，可以用括号控制）

```c
uint16_t Data=*(( __I0 uint16_t*)(0x08000000))
```

- **使用指针写指定地址下的存储器：**

```c
*((__Io uint16_t*)(0x08000000))= 0x1234;
```

读写Flash所需权限比较大，读写RAM就比较容易，因为在程序运行过程中是可读可写的。

- **其中：**

```c
#define	__IO	volatile
```

防止编译器优化。

### 3、程序存储器编程流程图

![1744201963194](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744201963194.png)

解锁，擦除，全擦除需要时间，程序会一直等待，判断寄存器BSY位是否为1，表示忙，继续循环等待，直到=0，跳出循环，全擦除结束。最后一步读出来验证工作量大就不管了。

### 4、程序存储器页擦除流程图

![1744201999065](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744201999065.png)

### 5、程序全擦除流程图

![1744202034078](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744202034078.png)

**检测到擦除之后，才执行写入操作，除非是写入0（即擦除）；**因为写入1可能会产生错误。

**==写入操作只能以半字（16位）写入操作。==**【字Word(32位)、半字halfWord(16位)、字节Byte(8位)】

写入8位就比较麻烦，如果想单独写入一字节的数据，还要保留另一字节数据，就必须把整页数据读到SRAM里，再随意进行SRAM数据，修改全部完成之后再把整页都擦除，再写回去。

写入32位数据分两次操作，写入很多则只需要不断循环操作就可以了。



## （五）选项字节

### 1、选项字节简介

![1744202080614](C:\Users\小小双的电脑\AppData\Roaming\Typora\typora-user-images\1744202080614.png)

名称前边都带着一个n，表示再写入**X**数据时候，要同时在**nX**写入数据的反码，这样操作才是有效的，如果芯片检测到不是反码的关系，就代表数据无效有错误，对应的功能就不执行，这是一种安全保障措施。这个写入反码操作硬件会自动写入操作，不需要我们担心。函数封装好了。

- **RDP：**写入RDPRT键(0x000000A5)后解除读保护**（默认可读）**
- **USER：**配置硬件看门狗和进入停机/待机模式是否产生复位
- **Data0/1：**用户可自定义使用
- **WRP0/1/2/3：**配置写保护，每一个位对应保护4个存储页(中容量)

### 2、选项字节编程

**==（选项字节本身页是闪存，写入也需要擦除）==**

- 检查FLASH_SR的BSY位，以确认没有其他正在进行的编程操作**（等待）**
- 解锁FLASH_CR的OPTWRE位
- 设置FLASH CR的OPTPG位为1
- 写入要编程的半字到指定的地址
- 等待BSY位变为0
- 读出写入的地址并验证数据

